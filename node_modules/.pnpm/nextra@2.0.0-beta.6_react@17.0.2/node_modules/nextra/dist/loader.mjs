var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/loader.ts
import path4 from "path";
import grayMatter2 from "gray-matter";
import slash2 from "slash";
import { Repository } from "@napi-rs/simple-git";

// src/content-dump.ts
import fs from "graceful-fs";
import path from "path";
var { statSync, mkdirSync } = fs;
var cacheDir = path.join(process.cwd(), ".next", "cache");
var assetDir = path.join(process.cwd(), ".next", "static", "chunks");
var asset = {};
var cached = /* @__PURE__ */ new Map();
try {
  statSync(assetDir);
} catch (e) {
  mkdirSync(assetDir, { recursive: true });
}
var cacheDirExist = false;
try {
  statSync(cacheDir);
  cacheDirExist = true;
} catch (e) {
  mkdirSync(cacheDir, { recursive: true });
}
function initFromCache(filename) {
  if (!cached.has(filename)) {
    try {
      const content = fs.readFileSync(path.join(assetDir, filename)).toString();
      cached.set(filename, true);
      return JSON.parse(content);
    } catch (err) {
      cached.set(filename, false);
    }
  }
  return {};
}
function addPage({
  fileLocale,
  route,
  title,
  data,
  structurizedData
}) {
  const dataFilename = `nextra-data-${fileLocale}.json`;
  asset[fileLocale] || (asset[fileLocale] = initFromCache(dataFilename));
  asset[fileLocale][route] = {
    title: title || data.title,
    data: structurizedData
  };
  const content = JSON.stringify(asset[fileLocale]);
  fs.writeFileSync(path.join(assetDir, dataFilename), content);
  fs.writeFileSync(path.join(cacheDir, dataFilename), content);
}

// src/utils.ts
import fs2 from "fs";
function getLocaleFromFilename(name) {
  const localeRegex = /\.([a-zA-Z-]+)?\.(mdx?|jsx?|json)$/;
  const match = name.match(localeRegex);
  if (match)
    return match[1];
}
function removeExtension(name) {
  const match = name.match(/^([^.]+)/);
  return match !== null ? match[1] : "";
}
var parseJsonFile = (content, path5) => {
  try {
    return JSON.parse(content);
  } catch (err) {
    console.error(`Error parsing ${path5}, make sure it's a valid JSON 
` + err);
    return {};
  }
};
var existsSync = (filePath) => {
  try {
    fs2.accessSync(filePath, fs2.constants.F_OK);
    return true;
  } catch (e) {
    return false;
  }
};

// src/compile.ts
import { createProcessor } from "@mdx-js/mdx";
import remarkGfm from "remark-gfm";
import rehypePrettyCode from "rehype-pretty-code";

// src/mdx-plugins/static-image.js
var relative = /^\.{1,2}\//;
function visit(node, type, handler) {
  if (node.type === type) {
    handler(node);
  }
  if (node.children) {
    node.children.forEach((n) => visit(n, type, handler));
  }
}
function ASTNodeImport(name, from) {
  return {
    type: "mdxjsEsm",
    value: `import ${name} from "${from}"`,
    data: {
      estree: {
        type: "Program",
        body: [
          {
            type: "ImportDeclaration",
            specifiers: [
              {
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name }
              }
            ],
            source: {
              type: "Literal",
              value: from,
              raw: `"${from}"`
            }
          }
        ],
        sourceType: "module"
      }
    }
  };
}
function remarkStaticImage() {
  return (tree, _file, done) => {
    const importsToInject = [];
    visit(tree, "image", visitor);
    tree.children.unshift(...importsToInject);
    tree.children.unshift(ASTNodeImport("$NextImageNextra", "next/image"));
    done();
    function visitor(node) {
      const url = node.url;
      if (url && relative.test(url)) {
        const tempVariableName = `$nextraImage${importsToInject.length}`;
        Object.assign(node, {
          type: "mdxJsxFlowElement",
          name: "$NextImageNextra",
          attributes: [
            {
              type: "mdxJsxAttribute",
              name: "alt",
              value: node.alt || ""
            },
            {
              type: "mdxJsxAttribute",
              name: "placeholder",
              value: "blur"
            },
            {
              type: "mdxJsxAttribute",
              name: "src",
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: tempVariableName,
                data: {
                  estree: {
                    type: "Program",
                    body: [
                      {
                        type: "ExpressionStatement",
                        expression: {
                          type: "Identifier",
                          name: tempVariableName
                        }
                      }
                    ],
                    sourceType: "module"
                  }
                }
              }
            }
          ],
          children: []
        });
        importsToInject.push(ASTNodeImport(tempVariableName, url));
      }
    }
  };
}

// src/mdx-plugins/remark.ts
function visit2(node, tester, handler) {
  if (tester(node)) {
    handler(node);
  }
  if (node.children) {
    node.children.forEach((n) => visit2(n, tester, handler));
  }
}
function getFlattenedValue(node) {
  return node.children.map((child) => "children" in child ? getFlattenedValue(child) : "value" in child ? child.value : "").join("");
}
function remarkHeadings() {
  const data = this.data();
  return (tree, _file, done) => {
    visit2(tree, (node) => {
      return node.type === "heading" || node.name === "summary" || node.name === "details";
    }, (node) => {
      if (node.type === "heading") {
        const heading = __spreadProps(__spreadValues({}, node), {
          value: getFlattenedValue(node)
        });
        const headingMeta = data.headingMeta;
        if (node.depth === 1) {
          headingMeta.hasH1 = true;
          if (Array.isArray(node.children) && node.children.length === 1) {
            const child = node.children[0];
            if (child.type === "text") {
              headingMeta.titleText = child.value;
            }
          }
        }
        headingMeta.headings.push(heading);
      } else if (node.name === "summary" || node.name === "details") {
        if (node.data) {
          delete node.data._mdxExplicitJsx;
        }
      }
    });
    done();
  };
}

// src/mdx-plugins/structurize.js
import Slugger from "github-slugger";
function cleanup(content) {
  return content.trim().split("\n").map((line) => line.trim()).join("\n");
}
var structurize_default = (structurizedData, options) => {
  if (typeof options === "boolean")
    options = {};
  options = Object.assign({ codeblocks: true }, options);
  const slugger = new Slugger();
  let activeSlug = "";
  let skip = false;
  let content = "";
  return function stripMarkdown() {
    return (node) => {
      walk(node);
      structurizedData[activeSlug] = cleanup(content);
      return node;
    };
    function walk(node) {
      let result = "";
      const type = node.type;
      if (type === "heading")
        skip = true;
      if (["code", "table", "blockquote", "list", "mdxJsxFlowElement"].includes(type)) {
        result += "\n";
        if (!skip)
          content += "\n";
      }
      if ("children" in node) {
        for (let i = 0; i < node.children.length; i++) {
          result += walk(node.children[i]);
        }
      } else if ([
        options.codeblocks ? "code" : "",
        "text",
        "inlineCode",
        "tableCell"
      ].includes(type)) {
        result += node.value;
        if (!skip)
          content += node.value;
      }
      if ([
        "code",
        "table",
        "blockquote",
        "list",
        "listItem",
        "break",
        "mdxJsxFlowElement"
      ].includes(type)) {
        result += "\n";
        if (!skip)
          content += "\n";
      }
      if (["tableCell"].includes(type)) {
        result += "	";
        if (!skip)
          content += "	";
      }
      if (type === "heading")
        skip = false;
      if (type === "heading" && node.depth > 1) {
        structurizedData[activeSlug] = cleanup(content);
        content = "";
        activeSlug = slugger.slug(result) + "#" + result;
      }
      return result;
    }
  };
};

// src/mdx-plugins/rehype-handler.js
import Slugger2 from "github-slugger";
function visit3(node, tagNames, handler) {
  if (tagNames.includes(node.tagName)) {
    handler(node);
    return;
  }
  if (node.children) {
    node.children.forEach((n) => visit3(n, tagNames, handler));
  }
}
function parseMeta() {
  return (tree) => {
    visit3(tree, ["pre"], (node) => {
      var _a, _b, _c;
      if (Array.isArray(node.children) && node.children.length === 1 && node.children[0].tagName === "code" && typeof node.children[0].properties === "object") {
        const meta = (_b = (_a = node.children[0].data) == null ? void 0 : _a.meta) != null ? _b : node.children[0].properties.metastring;
        if (meta) {
          const filename = (_c = meta.match(/filename="([^"]+)"/)) == null ? void 0 : _c[1];
          if (filename) {
            node.__nextra_filename__ = filename;
          }
        }
      }
    });
  };
}
function attachMeta() {
  return (tree) => {
    const slugger = new Slugger2();
    visit3(tree, ["div", "h2", "h3", "h4", "h5", "h6"], (node) => {
      if (node.tagName === "div") {
        if (!("data-rehype-pretty-code-fragment" in node.properties))
          return;
        node.properties["data-nextra-code"] = "";
        if ("__nextra_filename__" in node) {
          node.properties["data-filename"] = node.__nextra_filename__;
        }
      } else {
        node.properties.id = node.properties.id || slugger.slug(getFlattenedValue(node));
      }
    });
  };
}

// src/theme.json
var theme_default = {
  name: "css-variables",
  type: "light",
  colors: {
    "editor.foreground": "#000001",
    "editor.background": "#000002"
  },
  tokenColors: [
    {
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: [
        "markup.deleted",
        "meta.diff.header.from-file",
        "punctuation.definition.deleted"
      ],
      settings: {
        foreground: "#ef6270"
      }
    },
    {
      scope: [
        "markup.inserted",
        "meta.diff.header.to-file",
        "punctuation.definition.inserted"
      ],
      settings: {
        foreground: "#4bb74a"
      }
    },
    {
      scope: [
        "keyword.operator.accessor",
        "meta.group.braces.round.function.arguments",
        "meta.template.expression",
        "markup.fenced_code meta.embedded.block"
      ],
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: "emphasis",
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: ["strong", "markup.heading.markdown", "markup.bold.markdown"],
      settings: {
        fontStyle: "bold"
      }
    },
    {
      scope: ["markup.italic.markdown"],
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: "meta.link.inline.markdown",
      settings: {
        fontStyle: "underline",
        foreground: "#000004"
      }
    },
    {
      scope: ["string", "markup.fenced_code", "markup.inline"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      scope: ["comment", "string.quoted.docstring.multi"],
      settings: {
        foreground: "#000006"
      }
    },
    {
      scope: [
        "constant.numeric",
        "constant.language",
        "constant.other.placeholder",
        "constant.character.format.placeholder",
        "variable.language.this",
        "variable.other.object",
        "variable.other.class",
        "variable.other.constant",
        "meta.property-name",
        "meta.property-value",
        "support"
      ],
      settings: {
        foreground: "#000004"
      }
    },
    {
      scope: [
        "keyword",
        "storage.modifier",
        "storage.type",
        "storage.control.clojure",
        "entity.name.function.clojure",
        "entity.name.tag.yaml",
        "support.function.node",
        "support.type.property-name.json",
        "punctuation.separator.key-value",
        "punctuation.definition.template-expression"
      ],
      settings: {
        foreground: "#000007"
      }
    },
    {
      scope: "variable.parameter.function",
      settings: {
        foreground: "#000008"
      }
    },
    {
      scope: [
        "support.function",
        "entity.name.type",
        "entity.other.inherited-class",
        "meta.function-call",
        "meta.instance.constructor",
        "entity.other.attribute-name",
        "entity.name.function",
        "constant.keyword.clojure"
      ],
      settings: {
        foreground: "#000009"
      }
    },
    {
      scope: [
        "entity.name.tag",
        "string.quoted",
        "string.regexp",
        "string.interpolated",
        "string.template",
        "string.unquoted.plain.out.yaml",
        "keyword.other.template"
      ],
      settings: {
        foreground: "#000010"
      }
    },
    {
      scope: [
        "punctuation.definition.arguments",
        "punctuation.definition.dict",
        "punctuation.separator",
        "meta.function-call.arguments"
      ],
      settings: {
        foreground: "#000011"
      }
    },
    {
      name: "[Custom] Markdown links",
      scope: [
        "markup.underline.link",
        "punctuation.definition.metadata.markdown"
      ],
      settings: {
        foreground: "#000012"
      }
    },
    {
      name: "[Custom] Markdown list",
      scope: ["beginning.punctuation.definition.list.markdown"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      name: "[Custom] Markdown punctuation definition brackets",
      scope: [
        "punctuation.definition.string.begin.markdown",
        "punctuation.definition.string.end.markdown",
        "string.other.link.title.markdown",
        "string.other.link.description.markdown"
      ],
      settings: {
        foreground: "#000007"
      }
    }
  ]
};

// src/compile.ts
var createCompiler = (mdxOptions) => {
  const compiler = createProcessor(mdxOptions);
  compiler.data("headingMeta", {
    hasH1: false,
    headings: []
  });
  return compiler;
};
var rehypePrettyCodeOptions = {
  theme: theme_default,
  onVisitHighlightedLine(node) {
    if (!node.properties.className) {
      node.properties.className = [];
    }
    node.properties.className.push("highlighted");
  },
  onVisitHighlightedWord(node) {
    if (!node.properties.className) {
      node.properties.className = [];
    }
    node.properties.className.push("highlighted");
  }
};
function compileMdx(_0) {
  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {
    unstable_staticImage: false,
    unstable_flexsearch: false
  }, resourcePath) {
    var _a;
    let structurizedData = {};
    const compiler = createCompiler({
      jsx: (_a = mdxOptions.jsx) != null ? _a : true,
      outputFormat: mdxOptions.outputFormat,
      providerImportSource: "@mdx-js/react",
      remarkPlugins: [
        ...mdxOptions.remarkPlugins || [],
        remarkGfm,
        remarkHeadings,
        ...nextraOptions.unstable_staticImage ? [remarkStaticImage] : [],
        ...nextraOptions.unstable_flexsearch ? [structurize_default(structurizedData, nextraOptions.unstable_flexsearch)] : []
      ].filter(Boolean),
      rehypePlugins: [
        ...mdxOptions.rehypePlugins || [],
        parseMeta,
        [rehypePrettyCode, rehypePrettyCodeOptions],
        attachMeta
      ].filter(Boolean)
    });
    try {
      const result = yield compiler.process(source);
      return __spreadProps(__spreadValues({
        result: String(result)
      }, compiler.data("headingMeta")), {
        structurizedData
      });
    } catch (err) {
      console.error(`
Error compiling ${resourcePath}`);
      console.error(`${err}
`);
      throw err;
    }
  });
}

// src/page-map.ts
import path2 from "path";

// src/filter-route-locale.ts
function filterRouteLocale(pageMap, locale, defaultLocale) {
  const isDefaultLocale = !locale || locale === defaultLocale;
  const filteredPageMap = [];
  const fallbackPages = {};
  for (const page of pageMap) {
    if (page.children) {
      filteredPageMap.push(__spreadProps(__spreadValues({}, page), {
        children: filterRouteLocale(page.children, locale, defaultLocale)
      }));
      continue;
    }
    const localDoesMatch = !page.locale && isDefaultLocale || page.locale === locale;
    if (localDoesMatch) {
      fallbackPages[page.name] = null;
      filteredPageMap.push(page);
    } else {
      if (fallbackPages[page.name] !== null && (!page.locale || page.locale === defaultLocale)) {
        fallbackPages[page.name] = page;
      }
    }
  }
  for (const name in fallbackPages) {
    if (fallbackPages[name]) {
      filteredPageMap.push(fallbackPages[name]);
    }
  }
  return filteredPageMap;
}

// src/page-map.ts
var extension = /\.mdx?$/;
var metaExtension = /meta\.?([a-zA-Z-]+)?\.json/;
function findPagesDir(dir = process.cwd()) {
  if (existsSync(path2.join(dir, "pages")))
    return "pages";
  if (existsSync(path2.join(dir, "src/pages")))
    return "src/pages";
  throw new Error("> Couldn't find a `pages` directory. Please create one under the project root");
}
function getPageMap(currentResourcePath, pageMaps, fileMap, defaultLocale) {
  var _a, _b;
  const activeRouteLocale = getLocaleFromFilename(currentResourcePath);
  const pageItem = fileMap[currentResourcePath];
  const metaPath = path2.dirname(currentResourcePath);
  const metaExtension2 = activeRouteLocale ? `${activeRouteLocale}.json` : `json`;
  const pageMeta = (_b = (_a = fileMap[`${metaPath}/meta.${metaExtension2}`]) == null ? void 0 : _a.meta) == null ? void 0 : _b[pageItem.name];
  const title = (typeof pageMeta === "string" ? pageMeta : pageMeta == null ? void 0 : pageMeta.title) || pageItem.name;
  if (activeRouteLocale) {
    return [
      filterRouteLocale(pageMaps, activeRouteLocale, defaultLocale),
      fileMap[currentResourcePath].route,
      title
    ];
  }
  return [pageMaps, fileMap[currentResourcePath].route, title];
}

// src/plugin.ts
import fs3 from "graceful-fs";
import util from "util";
import path3 from "path";
import slash from "slash";
import grayMatter from "gray-matter";
var { readdir, readFile } = fs3;
function collectFiles(_0) {
  return __async(this, arguments, function* (dir, route = "/", fileMap = {}) {
    const files = yield util.promisify(readdir)(dir, { withFileTypes: true });
    const items = (yield Promise.all(files.map((f) => __async(this, null, function* () {
      const filePath = path3.resolve(dir, f.name);
      const fileRoute = slash(path3.join(route, removeExtension(f.name).replace(/^index$/, "")));
      if (f.isDirectory()) {
        if (fileRoute === "/api")
          return null;
        const { items: children } = yield collectFiles(filePath, fileRoute, fileMap);
        if (!children || !children.length)
          return null;
        return {
          name: f.name,
          children,
          route: fileRoute
        };
      } else if (extension.test(f.name)) {
        const locale = getLocaleFromFilename(f.name);
        const fileContents = yield util.promisify(readFile)(filePath, "utf-8");
        const { data } = grayMatter(fileContents);
        if (Object.keys(data).length) {
          fileMap[filePath] = {
            name: removeExtension(f.name),
            route: fileRoute,
            frontMatter: data,
            locale
          };
          return fileMap[filePath];
        }
        fileMap[filePath] = {
          name: removeExtension(f.name),
          route: fileRoute,
          locale
        };
        return fileMap[filePath];
      } else if (metaExtension.test(f.name)) {
        const content = yield util.promisify(readFile)(filePath, "utf-8");
        const meta = parseJsonFile(content, filePath);
        const locale = f.name.match(metaExtension)[1];
        fileMap[filePath] = {
          name: "meta.json",
          meta,
          locale
        };
        return fileMap[filePath];
      }
    })))).filter(Boolean);
    return {
      items,
      fileMap
    };
  });
}
var PageMapCache = class {
  constructor() {
    this.cache = { items: [], fileMap: {} };
  }
  set(data) {
    this.cache.items = data.items;
    this.cache.fileMap = data.fileMap;
  }
  clear() {
    this.cache = null;
  }
  get() {
    return this.cache;
  }
};
var pageMapCache = new PageMapCache();

// src/loader.ts
var extension2 = /\.mdx?$/;
var isProductionBuild = process.env.NODE_ENV === "production";
var indexContentEmitted = /* @__PURE__ */ new Set();
var pagesDir = path4.resolve(findPagesDir());
var [repository, gitRoot] = function() {
  try {
    const repo = Repository.discover(process.cwd());
    const gitRoot2 = path4.join(repo.path(), "..");
    return [repo, gitRoot2];
  } catch (e) {
    console.warn("Init git repository failed", e);
    return [];
  }
}();
function loader(context, source) {
  return __async(this, null, function* () {
    context.cacheable(true);
    const options = context.getOptions();
    let {
      theme,
      themeConfig,
      defaultLocale,
      unstable_flexsearch,
      unstable_staticImage,
      mdxOptions,
      pageMapCache: pageMapCache2
    } = options;
    const { resourcePath } = context;
    const filename = resourcePath.slice(resourcePath.lastIndexOf("/") + 1);
    const fileLocale = getLocaleFromFilename(filename);
    if (!theme) {
      throw new Error("No Nextra theme found!");
    }
    const { items: pageMapResult, fileMap } = isProductionBuild ? pageMapCache2.get() : yield collectFiles(pagesDir, "/");
    const [pageMap, route, title] = getPageMap(resourcePath, pageMapResult, fileMap, defaultLocale);
    if (!isProductionBuild) {
      context.addContextDependency(pagesDir);
    } else {
      Object.entries(fileMap).forEach(([filePath, { name, meta, locale }]) => {
        if (name === "meta.json" && meta && (!fileLocale || locale === fileLocale)) {
          context.addDependency(filePath);
        }
      });
    }
    let { data, content } = grayMatter2(source);
    let layout = theme;
    let layoutConfig = themeConfig || null;
    if (theme.startsWith(".") || theme.startsWith("/")) {
      layout = path4.resolve(theme);
    }
    if (layoutConfig) {
      layoutConfig = slash2(path4.resolve(layoutConfig));
    }
    if (isProductionBuild && indexContentEmitted.has(filename)) {
      unstable_flexsearch = false;
    }
    const { result, titleText, headings, hasH1, structurizedData } = yield compileMdx(content, mdxOptions, {
      unstable_staticImage,
      unstable_flexsearch
    }, resourcePath);
    content = result.replace("export default MDXContent;", "");
    if (unstable_flexsearch) {
      if (extension2.test(filename) && data.searchable !== false) {
        addPage({
          fileLocale: fileLocale || "default",
          route,
          title,
          data,
          structurizedData
        });
      }
      indexContentEmitted.add(filename);
    }
    let timestamp;
    if (repository && gitRoot) {
      if (repository.isShallow()) {
        if (process.env.VERCEL) {
          console.warn(`The repository is shallow cloned, so the latest modified time will not be presented. Set the VERCEL_DEEP_CLONE=true environment variable to enable deep cloning.`);
        } else if (process.env.GITHUB_ACTION) {
          console.warn(`The repository is shallow cloned, so the latest modified time will not be presented. See https://github.com/actions/checkout#fetch-all-history-for-all-tags-and-branches to fetch all the history.`);
        } else {
          console.warn(`The repository is shallow cloned, so the latest modified time will not be presented.`);
        }
      }
      try {
        timestamp = yield repository.getFileLatestModifiedDateAsync(path4.relative(gitRoot, resourcePath));
      } catch (e) {
      }
    }
    const layoutConfigImport = layoutConfig ? `import __nextra_layoutConfig__ from '${layoutConfig}'` : "";
    return `
import __nextra_withLayout__ from '${layout}'
import { withSSG as __nextra_withSSG__ } from 'nextra/ssg'
${layoutConfigImport}

const __nextra_pageMap__ = ${JSON.stringify(pageMap)}

globalThis.__nextra_internal__ = {
  pageMap: __nextra_pageMap__,
  route: ${JSON.stringify(route)}
}

const NextraLayout = __nextra_withSSG__(__nextra_withLayout__({
  filename: "${slash2(filename)}",
  route: "${slash2(route)}",
  meta: ${JSON.stringify(data)},
  pageMap: __nextra_pageMap__,
  titleText: ${JSON.stringify(titleText)},
  headings: ${JSON.stringify(headings)},
  hasH1: ${JSON.stringify(hasH1)},
  ${timestamp ? `timestamp: ${timestamp},
` : ""}
}, ${layoutConfig ? "__nextra_layoutConfig__" : "null"}))

${content}

function NextraPage(props) {
  return (
    <NextraLayout {...props}>
      <MDXContent />
    </NextraLayout>
  )
}
NextraPage.getLayout = NextraLayout.getLayout

export default NextraPage
`.trimStart();
  });
}
function syncLoader(source, callback) {
  loader(this, source).then((result) => callback(null, result)).catch((err) => callback(err));
}
export {
  syncLoader as default
};
